{%- extends 'layout.html' -%}
{%- block head -%}
    <link rel="stylesheet" type="text/css" href={{ url_for('static', filename='about.css') }}>
{%- endblock -%}
{%- block content -%}
<div class="container">
  <div class="row">
    <div class="span3 about-sidebar">
        <ul class="nav nav-list bs-docs-sidenav affix">
          <li>
            <a href="#intro">
              Introduction
              <i class="icon-chevron-right"></i>
            </a>
          </li>
          <li>
            <a href="#distinctives">
              Distinctives
              <i class="icon-chevron-right"></i>
            </a>
          </li>
          <li>
            <a href="#howto">
              How To
              <i class="icon-chevron-right"></i>
            </a>
          </li>
          <!--<li>-->
            <!--<a href="#glossary">-->
              <!--Glossary-->
              <!--<i class="icon-chevron-right"></i>-->
            <!--</a>-->
          <!--</li>-->
          <li>
            <a href="#references">
              References
              <i class="icon-chevron-right"></i>
            </a>
          </li>
          <li>
            <a href="#citing">
              Citing
              <i class="icon-chevron-right"></i>
            </a>
          </li>
          <!--<li>-->
            <!--<a href="#contact">-->
              <!--Contact-->
              <!--<i class="icon-chevron-right"></i>-->
            <!--</a>-->
          <!--</li>-->
        </ul>
    </div>
    <div class="span9">
      <section id="intro">
        <div class="page-header">
          <h1>Introduction</h1>
        </div>
        <p>Optimality Theory is a linguistic theory developed by Alan Prince and
        Paul Smolensky (Prince and Smolensky 1993). Partial Order Optimality
        Theory is a conservative generalization of the classical theory that
        allows one to describe and explain variation. This web application
        provides tools for working with both theories.</p>
      </section>
      <section id="distinctives">
        <div class="page-header">
          <h1>Distinctives</h1>
          <p>What separates this from other OT software?</p>
        </div>
        <h3>Number of optimal candidates</h3>
          <p>
            In classical OT, only one candidate can be optimal. In partial
            order OT, multiple candidates can be optimal. This is useful for
            modelling variation. For example: for a given input, multiple outputs may appear
            in the same dialect (e.g. multiple pronunciations of "data").
          </p>
        <h3>Finding all grammars</h3>
          <p>
            Most learning algorithms can find a single grammar that is compatible with
            the data. OTOrder finds all the grammars compatible with the data. This is
            made possible by the algorithm described in Djalali 2013.
          </p>
        <h3>Complexity</h3>
          <p>
            Along with finding all the grammars compatible with the data,
            OTOrder lists them in terms of their complexity, beginning with the
            simplest, as per Occam's Razor. Complexity is measured in two ways:
          </p>
          <ol>
            <li>
              <strong>Grammar size.</strong> Since a grammar is an ordering of
              the constraints, it can be expressed as a set of ordered pairs.
              One pair <i>(C<sub>1</sub>, C<sub>2</sub>)</i> means that
              <i>C<sub>1</sub></i> dominates <i>C<sub>2</sub></i>. Grammar size
              refers to the number of such ordered pairs, or rankings, present in
              the given grammar. Larger grammars are more complicated than smaller
              grammars, as they are more restrictive and contain more information.
            </li>
            <li>
              <strong>Ranking volume.</strong> Each grammar is a partial order of
              the set of constraints, and every partial order is compatible with
              a certain number of total orders. This number is the ranking volume
              of that grammar. For example, given the constraints
              <i>C<sub>1</sub>, C<sub>2</sub></i>, and <i>C<sub>3</sub></i> and the
              partial order {<i>C<sub>1</sub></i> &raquo; <i>C<sub>3</sub></i>,
              <i>C<sub>2</sub></i> &raquo; <i>C<sub>3</sub></i>}, there are two
              total orders that are compatible. They are <i>C<sub>1</sub></i> &raquo;
              <i>C<sub>2</sub></i> &raquo; <i>C<sub>3</sub></i> and <i>C<sub>2</sub></i>
              &raquo; <i>C<sub>1</sub></i> &raquo; <i>C<sub>3</sub></i>. The original
              grammar has a ranking volume of size two.
            </li>
          </ol>
          <h4>A note on statistics</h4>
          <p>
            Just as the ranking volume can be calculated for a whole grammar, a
            ranking volume can be calculated for each candidate. Given a grammar
            and its set of compatible total orders, a certain number of those
            total orders select for each candidate.
          </p>
          <p>
            This subset of the subset of total orders is the ranking volume for
            each candidate, and the distribution of percentages across the
            candidates gives an empirically falsifiable prediction of
            variation.
          </p>
        <h3>Global entailments</h3>
          <p>
            OTOrder also finds entailments between input-output pairs
            (candidates), i.e. implicational universals. We refer to these as
            global entailments. These are useful for exploring linguistic
            typologies. If a certain candidate wins, i.e. is present in a language,
            what other candidates are guaranteed to also be present in the language?
          </p>
        <h3>Visualizing graphs</h3>
          <p>
            OTOrder visualizes graphs for every grammar calculated, as well as the
            graph of global entailments. These graphs are displayed in PNG format
            and users are encouraged to download them for use in publications.
          </p>
      </section>
      <section id="howto">
        <div class="page-header">
          <h1>How to use this website</h1>
        </div>
        <h3>Calculator</h3>
          Begin by going to <a href="{{ url_for('tools.calculator') }}">the calculator page</a> and entering a dataset. Enter inputs, outputs, constraints, and the
          number of violations each candidate has on each constraint. Any of the violation boxes that are left empty default to 0. You can also choose a title for your dataset
          by typing in the "Dataset Title" box. If you do not specify a title, a random string will be chosen for the title of your dataset. Once you have finished editing,
          choose "All grammars" or "Classical grammars", depending on whether you want only the totally-ordered grammars (as in classical OT) or all the grammars, partially- and
          totally-ordered. Once you click to choose, you will be redirected to the grammars page.
        <h3>Grammars</h3>
          The grammars page may take a few minutes to load, as it calculates the compatible grammars for your dataset. Once it has finished loading, you will see several things:
            <h4>Global statistics</h4>
              A chart with global statistics, that displays the numbers of partial and classical grammars that are compatible with your dataset, along with the total number of
              possible grammars of each type and the percentage of possible grammars that are compatible with your data.
              <p></p><p>
              Beneath this chart is a set of links to global entailments and to edit the dataset.
              </p>
            <h4>Grammar navigation</h4>
              At the bottom of the page the compatible grammars will be displayed, along with some controls to navigate the set of grammars. There is a selector box to choose
              the measure of complexity by which the grammars are sorted. The options are ranking volume and grammar size, and the default is ranking volume. In either case,
              the simplest (smallest size or largest ranking volume) grammars are displayed initially. Changing the sorting key causes the grammars to be recalculated and
              re-sorted. Below the selection box is a row of numbered buttons, with the rightmost button depressed. The numbers depend on the sorting key. If the grammars are
              sorted by size, clicking on a number will display the grammars of that size. If they are sorted by ranking volume, clicking on a number will display all the
              grammars with that ranking volume. If there are too many grammars to display on one page, the "Prev" and "Next" buttons can be used to navigate further.
            <h4>Grammars</h4>
              Finally, the grammars themselves will be displayed at the bottom of the page. For each grammar, the set notation will be displayed on top. Every ordered pair
              <i>(C<sub>1</sub>, C<sub>2</sub>)</i> in the set denotes that <i>C<sub>1</sub></i> outranks <i>C<sub>2</sub></i>. On the left is a graphic visualization of
              the grammar, where each node is a constraint, and an arrow from <i>C<sub>1</sub></i> to <i>C<sub>2</sub></i> denotes that <i>C<sub>1</sub></i> outranks
              <i>C<sub>2</sub></i>. On the right is a table with statistics for that grammar. For each output in an input group, the number and percentage of that grammar's
              compatible total orders that cause it to win are displayed. In other words, each candidate's ranking volume is displayed. The distribution of percentages gives an
              empirically falsifiable prediction of variation for that grammar.
              <p></p><p>
              Click on the "Global entailments" link under the global statistics, which will redirect you to another page.
              </p>
        <h3>Entailments</h3>
          The global entailments page may take a few minutes to load, and once it has loaded it displays a few navigation links and a graph of all the global entailments for
          your dataset. In the graph, each node represents an input-output pair (candidate). If multiple candidates are listed in one node, they are part of an entailment cycle
          in which each candidate entails each other candidate in the cycle. They are therefore functionally equivalent, and can be listed in a single node. An arrow from node
          <i>N<sub>1</sub></i> to <i>N<sub>2</sub></i> indicates that all the candidates listed in <i>N<sub>1</sub></i> entail the candidates in <i>N<sub>2</sub></i>.
          Entailments are transitive, so everything entailed by the candidates in <i>N<sub>2</sub></i> is also entailed by <i>N<sub>2</sub></i>. Click on the "Edit dataset"
          link.
        <h3>Saving</h3>
          If you are not logged in, attempting to edit your dataset will redirect you to a login page. Log in, if you would like to save the work on your dataset and be able to
          edit and come back to it in the future. If you do not have an account, click on the "Create one" link at the bottom of the page. Logging in will automatically save the
          dataset to your account. After logging in, you will be able to edit your dataset as often as you would like, experimenting with how changes affect changes to the
          compatible grammars and global entailments.
        <h3>Account</h3>
          To view the list of your datasets, log in and click on your username in the upper right hand corner. From the dropdown menu, click on "View account". This redirect you
          to your account page, where you can see all of your datasets. For each dataset, there are links to the grammars and entailments, and buttons to edit, copy, or delete
          the dataset. Copying the dataset creates an exact copy which you can edit, if you would like to have multiple variations of the same dataset without re-entering from
          scratch.
        <p></p>
        <p>Good luck and enjoy!</p>
      </section>
      <!--<section id="glossary">-->
        <!--<div class="page-header">-->
          <!--<h1>Glossary</h1>-->
        <!--</div>-->
        <!--<div class="vert-spacer"></div>-->
      <!--</section>-->
      <section id="references">
        <div class="page-header">
          <h1>References</h1>
          <p>
            An alphabetical list of references used in the construction of this
            website and relevant background reading.
          </p>
        </div>
        <p class="citation">
          <strong>Anttila, Arto.</strong> 1997. ‘Deriving variation from grammar’. In Frans
          Hinskens, Roeland van Hout, &amp; Leo Wetzels (eds.), Variation, Change
          and Phonological Theory, Amsterdam / Philadelphia: John Benjamins,
          pp. 35-68.
        </p>

        <p class="citation">
        <strong>Anttila, Arto and Young-mee Yu Cho.</strong> 1998. ‘Variation and change in
        Optimality Theory’, Lingua 104, 31-56. Special issue on Conflicting
        Constraints.
        </p>

        <p class="citation">
        <strong>Anttila, Arto and Curtis Andrus.</strong> 2006. ‘T-Order Generator, software
        package’, Stanford University,
        http://www.stanford.edu/~anttila/research/software.html.
        </p>

        <p class="citation">
        <strong>Brasoveanu, Adrian and Alan Prince.</strong> 2011. ‘Ranking and necessity: the
        Fusional Reduction Algorithm’, Natural Language and Linguistic Theory,
        29, 3-70.
        </p>

        <p class="citation">
        <strong>Djalali, Alex J.</strong> 2013. ‘A constructive solution to the ranking problem
        in Partial Order Optimality Theory’, Ms., Stanford University.
        </p>

        <p class="citation">
        <strong>Kiparsky, Paul.</strong> 1993. ‘An OT Perspective on phonological
        variation’. Handout from Rutgers Optimality Workshop 1993, also
        presented at NWAVE 1994, Stanford University. Available at
        http://www.stanford.edu/~kiparsky/Papers/nwave94.pdf.
        </p>

        <p class="citation">
        <strong>Prince, Alan.</strong> 2002a. ‘Entailed ranking arguments’. [ROA-500].
        </p>

        <p class="citation">
        <strong>Prince, Alan.</strong> 2002b. ‘Arguing Optimality’. [ROA-562].
        </p>

        <p class="citation">
        <strong>Prince, Alan.</strong> 2006. 'Implication & Impossibility in Grammatical
        Systems'. [ROA-880].
        </p>

        <p class="citation">
        <strong>Prince, Alan.</strong> 2007. ‘The pursuit of theory’, in Paul de Lacy (ed.),
        The Cambridge handbook of phonology, Cambridge University Press,
        Cambridge, pp. 33-60.
        </p>

        <p class="citation">
        <strong>Prince, Alan and Paul Smolensky.</strong> 1993/2004. Optimality Theory:
        Constraint Interaction in Generative Grammar, Blackwell Publishing,
        Malden, Massachusetts.
        </p>
      </section>
      <section id="citing">
        <div class="page-header">
          <h1>How to cite this website</h1>
        </div>
        <p>
          Please feel free to use this website and any graphics, statistics,
          or other results in your papers, posters, or other publications. We just ask
          that you include the following citation as one of your references:
        </p>
        <p>
          <strong>
            Djalali, Alex J. and Cameron Jeffers. 2014. ‘OTOrder,
            software package’, Stanford University, http://www.otorder.com.
          </strong>
        </p>
      </section>
      <!--<section id="contact">-->
        <!--<div class="page-header">-->
          <!--<h1>Contact us</h1>-->
        <!--</div>-->
        <!--<div class="vert-spacer"></div>-->
      <!--</section>-->
    </div>
  </div>
</div>
<div id="bottom-spacer"></div>
{%- endblock -%}
